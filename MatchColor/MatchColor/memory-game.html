<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Memory Zen</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Varela+Round&display=swap" rel="stylesheet">
    <script src="audio.js"></script>
    <style>
        body {
            font-family: 'Varela Round', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            min-height: 100vh;
            margin: 0;
            background: radial-gradient(1200px 800px at 10% 10%, #0b1020 0%, #0f172a 40%, #0b1020 100%);
            color: #e5e7eb;
            padding: 4px 4px 0 4px;
            box-sizing: border-box;
            overflow-x: hidden;
            width: 100%;
            padding-top: 10vh;
        }

        h1 {
            margin: 0 0 8px 0;
            font-size: 2.4rem;
            letter-spacing: 0.5px;
            background: linear-gradient(90deg, #a78bfa, #60a5fa, #34d399);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 4px 24px rgba(99,102,241,0.35);
            transition: opacity 0.3s ease;
        }

        h1.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .info-bar {
            display: flex;
            gap: 12px;
            align-items: center;
            justify-content: center;
            padding: 8px 12px;
            border-radius: 14px;
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(148,163,184,0.15);
            box-shadow: 0 10px 30px rgba(0,0,0,0.35), inset 0 0 60px rgba(99,102,241,0.06);
            margin-bottom: 10px;
            backdrop-filter: blur(6px);
        }

        .info-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.05rem;
            font-weight: 600;
            color: #cbd5e1;
        }

        .info-item .value {
            color: #f8fafc;
        }
        
        #game-container {
            position: relative;
            display: grid;
            gap: 10px;
            padding: 16px;
            border-radius: 20px;
            background: linear-gradient(180deg, rgba(30,41,59,0.65), rgba(2,6,23,0.8));
            border: 1px solid rgba(148,163,184,0.18);
            box-shadow: 0 20px 60px rgba(0,0,0,0.45), inset 0 1px 0 rgba(148,163,184,0.25);
            margin: 0 auto;
            justify-content: center;
            align-content: center;
            grid-area: game;
        }

        @media (max-width: 540px) {
            h1 { font-size: 2rem; }
            body {
                overflow-x: hidden;
                padding: 2px 2px 0 2px;
                margin: 0;
                padding-top: 8vh;
            }
            #game-container { 
                width: 100%;
                max-width: 100%;
                padding: 8px; 
                gap: 4px;
                justify-content: center;
                align-content: center;
                margin: 0;
                border-radius: 0;
                box-sizing: border-box;
            }
            .info-item { font-size: 0.9rem; }
            .info-bar {
                padding: 8px 12px;
                gap: 8px;
            }
        }

        @media (max-width: 360px) {
            h1 { font-size: 1.8rem; }
            body { 
                padding: 1px 1px 0 1px;
                padding-top: 6vh;
            }
            #game-container { 
                padding: 4px; 
                gap: 2px;
            }
            .info-item { font-size: 0.8rem; }
            .info-bar {
                padding: 6px 8px;
                gap: 6px;
            }
        }

        .card {
            border-radius: 16px;
            cursor: pointer;
            aspect-ratio: 1 / 1;
            border: 1px solid rgba(148,163,184,0.12);
            box-shadow: 0 10px 26px rgba(0,0,0,0.45);
            transition: transform 0.35s ease, box-shadow 0.35s ease, border-color 0.35s ease, filter 0.35s ease;
            transform-style: preserve-3d;
            position: relative;
            overflow: hidden;
        }

        .card::after {
            content: '?';
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #94a3b8;
            font-size: clamp(22px, 6vw, 36px);
            opacity: 0.7;
            transition: opacity 0.25s ease;
        }

        .card:hover { border-color: rgba(99,102,241,0.45); box-shadow: 0 16px 38px rgba(99,102,241,0.25); }
        .card.flipped::after { opacity: 0; }

        .card.flipped { transform: rotateY(180deg) scale(0.98); }

        .card .front-face, .card .back-face {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 16px;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .card .front-face {
            background: radial-gradient(100% 100% at 30% 20%, #111827 0%, #0b1020 70%);
        }

        .card .back-face {
            transform: rotateY(180deg);
            box-shadow: inset 0 0 24px rgba(255,255,255,0.1);
        }
        
        #game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(2,6,23,0.82);
            border-radius: 18px;
            text-align: center;
            padding: 24px;
            box-sizing: border-box;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            border: 1px solid rgba(148,163,184,0.18);
            backdrop-filter: blur(8px);
        }

        #game-overlay.visible { opacity: 1; pointer-events: auto; }

        #overlay-title {
            font-size: 1.8rem;
            margin: 0 0 8px 0;
            color: #f1f5f9;
        }
        #overlay-subtitle { color: #cbd5e1; margin-bottom: 18px; font-size: 1rem; }
        #overlay-time { font-size: 1.2rem; margin-bottom: 12px; color: #93c5fd; }
        #overlay-stars { font-size: 1.6rem; margin-bottom: 18px; }

        #restart-button {
            padding: 12px 20px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            background: linear-gradient(90deg, #3b82f6, #22c55e);
            color: white;
            border: none;
            border-radius: 12px;
            box-shadow: 0 10px 24px rgba(34,197,94,0.25);
            transition: transform 0.1s ease, filter 0.2s ease;
        }
        #restart-button:hover { filter: brightness(1.1); }
        #restart-button:active { transform: translateY(1px); }

        .hidden { display: none !important; }

        /* Audio toggle buttons */
        .audio-toggle-btn {
            background: rgba(148,163,184,0.2);
            border: 1px solid rgba(148,163,184,0.3);
            border-radius: 8px;
            padding: 6px 8px;
            margin: 0 2px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s ease;
            color: #cbd5e1;
        }

        .audio-toggle-btn:hover {
            background: rgba(148,163,184,0.3);
            border-color: rgba(148,163,184,0.5);
        }

        .audio-toggle-btn.active {
            background: rgba(34,197,94,0.3);
            border-color: rgba(34,197,94,0.5);
            color: #22c55e;
        }

        /* Moldura de referÃªncia com emojis */
        .reference-frame {
            position: relative;
            display: grid;
            grid-template-areas: 
                "info-top info-top info-top"
                "left game right"
                "info-bottom info-bottom info-bottom";
            grid-template-columns: 1fr auto 1fr;
            grid-template-rows: auto 1fr auto;
            gap: 8px;
            padding: 8px;
            border-radius: 14px;
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(148,163,184,0.15);
            box-shadow: 0 8px 24px rgba(0,0,0,0.25), inset 0 0 40px rgba(99,102,241,0.04);
            margin-bottom: 8px;
            backdrop-filter: blur(6px);
            max-width: 95%;
        }

        .game-info-top {
            grid-area: info-top;
            display: flex;
            justify-content: center;
            gap: 16px;
            font-size: 0.8rem;
            color: #cbd5e1;
            opacity: 0.8;
        }

        .game-info-bottom {
            grid-area: info-bottom;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 16px;
            font-size: 0.8rem;
            color: #cbd5e1;
            opacity: 0.8;
        }

        .audio-controls {
            display: flex;
            gap: 4px;
        }

        .reference-group {
            display: flex;
            gap: 4px;
            align-items: center;
            justify-content: center;
        }

        .reference-right {
            grid-area: right;
            flex-direction: column;
        }

        .reference-left {
            grid-area: left;
            flex-direction: column;
        }

        .reference-emojis {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            align-items: center;
        }

        .reference-emoji {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 50px;
            height: 50px;
            border-radius: 12px;
            background: rgba(30,41,59,0.8);
            border: 1px solid rgba(148,163,184,0.2);
            font-size: 1.8rem;
            transition: all 0.3s ease;
            position: relative;
        }

        .reference-emoji.found {
            background: rgba(34,197,94,0.2);
            border-color: rgba(34,197,94,0.4);
            opacity: 0.6;
            transform: scale(0.9);
        }

        .reference-emoji.found::after {
            content: 'âœ“';
            position: absolute;
            top: -2px;
            right: -2px;
            width: 16px;
            height: 16px;
            background: #22c55e;
            color: white;
            border-radius: 50%;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        @media (max-width: 540px) {
            .reference-frame {
                padding: 6px 8px;
                margin-bottom: 8px;
                gap: 6px;
            }
            
            .game-info-top, .game-info-bottom {
                font-size: 0.7rem;
                gap: 12px;
            }
            
            .reference-emoji {
                width: 36px;
                height: 36px;
                font-size: 1.2rem;
            }
            
            .reference-group {
                gap: 3px;
            }
        }

        @media (max-width: 360px) {
            .reference-frame {
                padding: 4px 6px;
                margin-bottom: 6px;
                gap: 4px;
            }
            
            .game-info-top, .game-info-bottom {
                font-size: 0.65rem;
                gap: 8px;
            }
            
            .reference-emoji {
                width: 32px;
                height: 32px;
                font-size: 1rem;
            }
            
            .reference-group {
                gap: 2px;
            }
        }

        /* Painel de PowerUps */
        .powerup-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 12px;
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(148,163,184,0.15);
            box-shadow: 0 6px 20px rgba(0,0,0,0.2), inset 0 0 30px rgba(99,102,241,0.03);
            margin-bottom: 10px;
            backdrop-filter: blur(6px);
            max-width: 90%;
        }

        .powerup-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: #cbd5e1;
            margin: 0;
        }

        .powerup-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: center;
            align-items: center;
        }

        .powerup-btn {
            padding: 6px 10px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            background: rgba(30,41,59,0.8);
            border: 1px solid rgba(148,163,184,0.3);
            border-radius: 8px;
            color: #cbd5e1;
            transition: all 0.2s ease;
            min-width: 80px;
        }

        .powerup-btn:hover:not(:disabled) {
            background: rgba(99,102,241,0.2);
            border-color: rgba(99,102,241,0.4);
            color: #a78bfa;
        }

        .powerup-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .powerup-btn.insufficient-points {
            opacity: 0.5;
            cursor: not-allowed;
        }

        @media (max-width: 540px) {
            .powerup-panel {
                padding: 8px 10px;
                margin-bottom: 10px;
            }
            
            .powerup-title {
                font-size: 0.75rem;
            }
            
            .powerup-btn {
                padding: 4px 8px;
                font-size: 0.7rem;
                min-width: 70px;
            }
            
            .powerup-buttons {
                gap: 4px;
            }
        }

        @media (max-width: 360px) {
            .powerup-panel {
                padding: 6px 8px;
                margin-bottom: 8px;
            }
            
            .powerup-btn {
                padding: 3px 6px;
                font-size: 0.65rem;
                min-width: 60px;
            }
        }
    </style>
</head>
<body>

    <h1 id="game-title">Memory Zen</h1>

    <!-- Moldura de referÃªncia com emojis organizados nas laterais -->
    <div class="reference-frame" id="reference-frame">
        <!-- InformaÃ§Ãµes do jogo na parte superior -->
        <div class="game-info-top">
            <span>Level: <span class="value" id="level">1</span></span>
            <span>Pares: <span class="value" id="pairs-found">0</span>/<span class="value" id="total-pairs">2</span></span>
            <span>Tempo: <span class="value" id="level-time">00:00</span></span>
        </div>
        
        <!-- Grupo Direita -->
        <div class="reference-group reference-right" id="reference-right"></div>
        
        <!-- Grupo Esquerda -->
        <div class="reference-group reference-left" id="reference-left"></div>
        
        <!-- InformaÃ§Ãµes do jogo na parte inferior -->
        <div class="game-info-bottom">
            <span>PowerUps: <span class="value" id="powerup-points">0</span></span>
            <span>Erros: <span class="value" id="consecutive-misses">0</span></span>
            <div class="audio-controls">
                <button class="audio-toggle-btn" id="music-toggle" title="MÃºsica">ğŸµ</button>
                <button class="audio-toggle-btn" id="sfx-toggle" title="Efeitos Sonoros">ğŸ”Š</button>
            </div>
        </div>
        
        <!-- Container do jogo integrado -->
        <div id="game-container">
            <div id="game-overlay">
                <div id="overlay-title">Pronto para comeÃ§ar?</div>
                <div id="overlay-subtitle">Encontre todos os pares o mais rÃ¡pido possÃ­vel.</div>
                <div id="overlay-time" class="hidden">Tempo: <span id="overlay-time-value">00:00</span></div>
                <div id="overlay-stars" class="hidden">â­ï¸â­ï¸â­ï¸â­ï¸â­ï¸</div>
                <button id="restart-button">Iniciar Jogo</button>
            </div>
        </div>
    </div>

    <!-- Painel de PowerUps -->
    <div class="powerup-panel" id="powerup-panel">
        <div class="powerup-title">PowerUps DisponÃ­veis:</div>
        <div class="powerup-buttons">
            <button class="powerup-btn" id="reveal-1s" title="Revelar cards por 1 segundo (1 ponto)">
                ğŸ‘ï¸ 1s (1)
            </button>
            <button class="powerup-btn" id="reveal-2s" title="Revelar cards por 2 segundos (4 pontos)">
                ğŸ‘ï¸ 2s (4)
            </button>
            <button class="powerup-btn" id="reveal-3s" title="Revelar cards por 3 segundos (8 pontos)">
                ğŸ‘ï¸ 3s (8)
            </button>
            <button class="powerup-btn" id="solve-emoji" title="Resolver um emoji especÃ­fico (4 pontos)">
                ğŸ¯ Resolver (4)
            </button>
        </div>
    </div>

    <script>
        const gameContainer = document.getElementById('game-container');
        const levelElement = document.getElementById('level');
        const pairsFoundElement = document.getElementById('pairs-found');
        const totalPairsElement = document.getElementById('total-pairs');
        const levelTimeElement = document.getElementById('level-time');
        const overlayTime = document.getElementById('overlay-time');
        const overlayTimeValue = document.getElementById('overlay-time-value');
        const overlayStars = document.getElementById('overlay-stars');
        const restartButton = document.getElementById('restart-button');
        const gameOverlay = document.getElementById('game-overlay');
        const musicToggle = document.getElementById('music-toggle');
        const sfxToggle = document.getElementById('sfx-toggle');
        const referenceEmojis = document.getElementById('reference-emojis');
        const powerUpPointsElement = document.getElementById('powerup-points');
        const consecutiveMissesElement = document.getElementById('consecutive-misses');
        const reveal1sBtn = document.getElementById('reveal-1s');
        const reveal2sBtn = document.getElementById('reveal-2s');
        const reveal3sBtn = document.getElementById('reveal-3s');
        const solveEmojiBtn = document.getElementById('solve-emoji');
        
        let gridSize;
        let pairsFound = 0;
        let totalPairs = 0;
        let level = 1;
        let isBoardLocked = false;
        let firstCard = null;
        let secondCard = null;
        let levelStartTs = null;
        let tick = null;
        let audioSystem = null;
        let currentLevelEmojis = []; // Array para armazenar os emojis do nÃ­vel atual
        
        // Sistema de PowerUps
        let powerUpPoints = 0;
        let consecutiveHits = 0;
        let consecutiveMisses = 0;
        let lastActionWasHit = false;

        const bestTimes = new Map(); // level -> [best..worst]

        const baseColors = [
            '#FF6B6B', '#FFD166', '#06D6A0', '#118AB2', '#073B4C', '#A06D92', '#FFC0CB', '#7B9B8F',
            '#F9C74F', '#43AA8B', '#B8BEDD', '#6A4C93', '#F4978E', '#90A4AE', '#6D6875', '#B0D8A4'
        ];

        const emojis = [
            'ğŸ˜‚', 'ğŸ™ƒ', 'ğŸ« ', 'ğŸ˜‰', 'ğŸ˜Š', 'ğŸ¥°', 'ğŸ˜', 'ğŸ¤©', 'ğŸ˜˜', 'ğŸ˜‹',
            'ğŸ˜œ', 'ğŸ¤­', 'ğŸ«£', 'ğŸ¤”', 'ğŸ¤¨', 'ğŸ˜¶â€ğŸŒ«ï¸', 'ğŸ™„', 'ğŸ˜®â€ğŸ’¨', 'ğŸ™‚â€â†”ï¸', 'ğŸ™‚â€â†•ï¸',
            'ğŸ¤¤', 'ğŸ¥¶', 'ğŸ˜', 'ğŸ¤“', 'ğŸ™', 'ğŸ˜®', 'ğŸ¥º', 'ğŸ¥¹', 'ğŸ˜¨', 'ğŸ˜­',
            'ğŸ˜±', 'ğŸ¤¬', 'ğŸ’€', 'â˜ ï¸', 'ğŸ’©', 'ğŸ¤¡', 'ğŸ’”', 'â¤ï¸â€ğŸ”¥', 'â¤ï¸â€ğŸ©¹', 'â¤ï¸',
            'ğŸ©·', 'ğŸ§¡', 'ğŸ’›', 'ğŸ’š', 'ğŸ’™', 'ğŸ’œ', 'ğŸ¤', 'ğŸ’¬', 'ğŸ’­', 'ğŸ‘‰',
            'ğŸ‘‡', 'â˜ï¸', 'ğŸ«µ', 'ğŸ‘', 'ğŸ™Œ', 'ğŸ«¶', 'ğŸ¤', 'ğŸ™', 'ğŸ«€', 'ğŸ‘€',
            'ğŸ‹ï¸â€â™€ï¸', 'ğŸ«‚', 'ğŸ¦‹', 'ğŸš¨', 'ğŸš€', 'â˜€ï¸', 'â­', 'ğŸ”¥', 'âœ¨', 'ğŸ€',
            'ğŸ§¸', 'ğŸ­', 'ğŸ‘‘', 'ğŸ’', 'ğŸ¶', 'ğŸ’¸', 'ğŸ“ˆ', 'ğŸ“', 'âš–ï¸', 'ğŸ§¿',
            'ğŸª¬', 'ğŸ—¿', 'âš ï¸', 'ğŸ”', 'â¬†ï¸', 'â¡ï¸', 'â¬‡ï¸', 'â˜¯ï¸', 'â—', 'â™¾ï¸',
            'â“', 'â—', 'âš•ï¸', 'âœ…', 'âœ”ï¸'
        ];

        function getRandomHexColor() {
            return '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');
        }

        function getUniqueEmojis() {
            // Remove duplicatas do array de emojis
            return [...new Set(emojis)];
        }

        // Sistema de PowerUps
        function updatePowerUpPoints() {
            powerUpPointsElement.textContent = powerUpPoints;
            updatePowerUpButtons();
        }

        function updateConsecutiveMisses() {
            consecutiveMissesElement.textContent = consecutiveMisses;
        }

        function updatePowerUpButtons() {
            reveal1sBtn.disabled = powerUpPoints < 1;
            reveal2sBtn.disabled = powerUpPoints < 4;
            reveal3sBtn.disabled = powerUpPoints < 8;
            solveEmojiBtn.disabled = powerUpPoints < 4;
        }

        function addPowerUpPoints(hits) {
            const points = Math.floor(hits / 2);
            if (points > 0) {
                powerUpPoints += points;
                updatePowerUpPoints();
                console.log(`+${points} PowerUp points! (${hits} consecutive hits)`);
            }
        }

        function spendPowerUpPoints(cost) {
            if (powerUpPoints >= cost) {
                powerUpPoints -= cost;
                updatePowerUpPoints();
                return true;
            }
            return false;
        }

        function revealAllCards(duration) {
            if (isBoardLocked) return;
            
            const cards = document.querySelectorAll('.card:not(.found)');
            if (cards.length === 0) return;
            
            isBoardLocked = true;
            
            // Armazena o estado original dos cards (se jÃ¡ estavam revelados ou nÃ£o)
            const originalStates = new Map();
            cards.forEach(card => {
                originalStates.set(card, {
                    wasFlipped: card.classList.contains('flipped'),
                    wasVisible: card.style.color !== 'transparent'
                });
            });
            
            // Mostra todos os cards restantes
            cards.forEach(card => {
                card.style.background = card.dataset.color;
                card.style.color = 'white';
                card.classList.add('flipped');
            });
            
            // Esconde novamente apÃ³s o tempo especificado
            setTimeout(() => {
                cards.forEach(card => {
                    if (!card.classList.contains('found')) {
                        const originalState = originalStates.get(card);
                        
                        // Se o card nÃ£o estava originalmente revelado, esconde ele
                        if (!originalState.wasFlipped && !originalState.wasVisible) {
                            card.style.background = '#0b1020';
                            card.style.color = 'transparent';
                            card.classList.remove('flipped');
                        }
                        // Se o card estava originalmente revelado, mantÃ©m ele revelado
                        else if (originalState.wasFlipped || originalState.wasVisible) {
                            card.style.background = card.dataset.color;
                            card.style.color = 'white';
                            card.classList.add('flipped');
                        }
                    }
                });
                isBoardLocked = false;
            }, duration * 1000);
        }

        function solveSpecificEmoji() {
            if (isBoardLocked) return;
            
            // Encontra um emoji nÃ£o encontrado
            const unsolvedEmoji = currentLevelEmojis.find(item => !item.found);
            if (!unsolvedEmoji) return;
            
            // Encontra os cards com esse emoji
            const cards = document.querySelectorAll('.card');
            const targetCards = Array.from(cards).filter(card => 
                card.dataset.emoji === unsolvedEmoji.emoji && 
                !card.classList.contains('found')
            );
            
            if (targetCards.length >= 2) {
                // Bloqueia o tabuleiro durante a animaÃ§Ã£o
                isBoardLocked = true;
                
                // Mostra as cartas com animaÃ§Ã£o
                targetCards.forEach(card => {
                    card.style.background = card.dataset.color;
                    card.style.color = 'white';
                    card.classList.add('flipped');
                });
                
                // ApÃ³s um breve delay, marca como encontrado
                setTimeout(() => {
                    // Marca como encontrado
                    markEmojiAsFound(unsolvedEmoji.emoji);
                    pairsFound++;
                    pairsFoundElement.textContent = pairsFound;
                    
                    // Remove os event listeners e marca como encontrados
                    targetCards.forEach(card => {
                        card.removeEventListener('click', flipCard);
                        card.classList.add('found');
                    });
                    
                    // Desbloqueia o tabuleiro
                    isBoardLocked = false;
                    
                    // Verifica se o nÃ­vel foi completado
                    if (pairsFound === totalPairs) {
                        if (gridSize >= 10) {
                            endGame();
                        } else {
                            levelComplete();
                        }
                    }
                }, 800); // Delay de 800ms para mostrar a animaÃ§Ã£o
            }
        }

        function shuffleRemainingCards() {
            const remainingCards = document.querySelectorAll('.card:not(.found)');
            if (remainingCards.length === 0) return;
            
            const cardData = Array.from(remainingCards).map(card => ({
                emoji: card.dataset.emoji,
                color: card.dataset.color
            }));
            
            // Embaralha os dados
            const shuffledData = shuffle([...cardData]);
            
            // Cria animaÃ§Ã£o de embaralhamento
            createShuffleAnimation(remainingCards, () => {
                // Aplica os novos dados aos cards apÃ³s a animaÃ§Ã£o
                remainingCards.forEach((card, index) => {
                    card.dataset.emoji = shuffledData[index].emoji;
                    card.dataset.color = shuffledData[index].color;
                    card.textContent = shuffledData[index].emoji;
                });
            });
        }

        function createShuffleAnimation(cards, callback) {
            // Bloqueia interaÃ§Ã£o durante a animaÃ§Ã£o
            isBoardLocked = true;
            
            // Cria overlay de puniÃ§Ã£o
            const punishmentOverlay = document.createElement('div');
            punishmentOverlay.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(220, 38, 38, 0.9);
                color: white;
                padding: 16px 24px;
                border-radius: 12px;
                font-size: 1.3rem;
                font-weight: 700;
                z-index: 1000;
                border: 2px solid rgba(220, 38, 38, 0.8);
                box-shadow: 0 8px 24px rgba(220, 38, 38, 0.4);
                backdrop-filter: blur(8px);
                animation: punishmentPulse 0.5s ease-in-out;
            `;
            punishmentOverlay.textContent = 'âš ï¸ PUNIÃ‡ÃƒO: Cards Embaralhados! âš ï¸';
            gameContainer.appendChild(punishmentOverlay);
            
            // Adiciona CSS para animaÃ§Ã£o
            if (!document.getElementById('punishment-styles')) {
                const style = document.createElement('style');
                style.id = 'punishment-styles';
                style.textContent = `
                    @keyframes punishmentPulse {
                        0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
                        50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
                        100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                    }
                    @keyframes cardShuffle {
                        0% { transform: rotate(0deg) scale(1); }
                        25% { transform: rotate(5deg) scale(1.05); }
                        50% { transform: rotate(-5deg) scale(0.95); }
                        75% { transform: rotate(3deg) scale(1.02); }
                        100% { transform: rotate(0deg) scale(1); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Anima os cards individualmente
            Array.from(cards).forEach((card, index) => {
                setTimeout(() => {
                    card.style.animation = 'cardShuffle 0.3s ease-in-out';
                    setTimeout(() => {
                        card.style.animation = '';
                    }, 300);
                }, index * 50);
            });
            
            // Remove overlay e executa callback apÃ³s animaÃ§Ã£o
            setTimeout(() => {
                if (punishmentOverlay.parentNode) {
                    punishmentOverlay.parentNode.removeChild(punishmentOverlay);
                }
                isBoardLocked = false;
                if (callback) callback();
            }, 1500);
        }

        function revertLastHit() {
            // Encontra o Ãºltimo par encontrado e o reverte
            const foundCards = document.querySelectorAll('.card.found');
            if (foundCards.length >= 2) {
                const lastTwoCards = Array.from(foundCards).slice(-2);
                
                // Cria animaÃ§Ã£o de reversÃ£o
                createRevertAnimation(lastTwoCards, () => {
                    lastTwoCards.forEach(card => {
                        // Remove todas as classes e estilos de "encontrado"
                        card.classList.remove('found');
                        card.classList.remove('flipped');
                        
                        // Volta para o estado oculto
                        card.style.background = '#0b1020';
                        card.style.color = 'transparent';
                        
                        // Reativa o evento de clique
                        card.addEventListener('click', flipCard);
                    });
                    
                    pairsFound--;
                    pairsFoundElement.textContent = pairsFound;
                    
                    // Reverte na moldura de referÃªncia
                    const emoji = lastTwoCards[0].dataset.emoji;
                    const emojiRef = currentLevelEmojis.find(item => item.emoji === emoji);
                    if (emojiRef) {
                        emojiRef.found = false;
                        emojiRef.element.classList.remove('found');
                    }
                    
                    console.log('PuniÃ§Ã£o aplicada: Ãšltimo acerto revertido!');
                });
            }
        }

        function createRevertAnimation(cards, callback) {
            // Bloqueia interaÃ§Ã£o durante a animaÃ§Ã£o
            isBoardLocked = true;
            
            // Cria overlay de reversÃ£o
            const revertOverlay = document.createElement('div');
            revertOverlay.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(239, 68, 68, 0.9);
                color: white;
                padding: 14px 20px;
                border-radius: 10px;
                font-size: 1.2rem;
                font-weight: 700;
                z-index: 1000;
                border: 2px solid rgba(239, 68, 68, 0.8);
                box-shadow: 0 6px 20px rgba(239, 68, 68, 0.4);
                backdrop-filter: blur(8px);
                animation: revertPulse 0.4s ease-in-out;
            `;
            revertOverlay.textContent = 'ğŸ”„ REVERTENDO ACERTO!';
            gameContainer.appendChild(revertOverlay);
            
            // Adiciona CSS para animaÃ§Ã£o de reversÃ£o
            if (!document.getElementById('revert-styles')) {
                const style = document.createElement('style');
                style.id = 'revert-styles';
                style.textContent = `
                    @keyframes revertPulse {
                        0% { transform: translate(-50%, -50%) scale(0.7); opacity: 0; }
                        50% { transform: translate(-50%, -50%) scale(1.05); opacity: 1; }
                        100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                    }
                    @keyframes cardRevert {
                        0% { transform: scale(1) rotate(0deg); }
                        50% { transform: scale(0.8) rotate(180deg); }
                        100% { transform: scale(1) rotate(360deg); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Anima os cards sendo revertidos
            cards.forEach((card, index) => {
                setTimeout(() => {
                    card.style.animation = 'cardRevert 0.6s ease-in-out';
                    setTimeout(() => {
                        card.style.animation = '';
                    }, 600);
                }, index * 200);
            });
            
            // Remove overlay e executa callback apÃ³s animaÃ§Ã£o
            setTimeout(() => {
                if (revertOverlay.parentNode) {
                    revertOverlay.parentNode.removeChild(revertOverlay);
                }
                isBoardLocked = false;
                if (callback) callback();
            }, 1000);
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function createReferenceFrame(cardData) {
            // Limpa os grupos laterais
            document.getElementById('reference-right').innerHTML = '';
            document.getElementById('reference-left').innerHTML = '';
            currentLevelEmojis = [];
            
            // Divide os emojis em 2 grupos (esquerda e direita)
            const totalEmojis = cardData.length;
            const emojisPerGroup = Math.ceil(totalEmojis / 2);
            
            // Cria elementos de referÃªncia para cada emoji Ãºnico
            cardData.forEach((item, index) => {
                const emojiElement = document.createElement('div');
                emojiElement.classList.add('reference-emoji');
                emojiElement.textContent = item.emoji;
                emojiElement.dataset.emoji = item.emoji;
                emojiElement.id = `ref-emoji-${index}`;
                
                // Determina em qual grupo colocar o emoji (apenas laterais)
                let targetGroup;
                if (index < emojisPerGroup) {
                    targetGroup = document.getElementById('reference-left');
                } else {
                    targetGroup = document.getElementById('reference-right');
                }
                
                targetGroup.appendChild(emojiElement);
                currentLevelEmojis.push({
                    element: emojiElement,
                    emoji: item.emoji,
                    found: false
                });
            });
        }

        function markEmojiAsFound(emoji) {
            const emojiRef = currentLevelEmojis.find(item => 
                item.emoji === emoji && !item.found
            );
            
            if (emojiRef) {
                emojiRef.found = true;
                emojiRef.element.classList.add('found');
            }
        }

        function showAllEmojisPreview() {
            const cards = document.querySelectorAll('.card');
            
            // Calcula o tempo de exposiÃ§Ã£o baseado no nÃ­vel
            const getPreviewTime = (currentLevel) => {
                if (currentLevel <= 2) return 3000;      // NÃ­veis 1-2: 3 segundos
                if (currentLevel <= 4) return 2500;      // NÃ­veis 3-4: 2.5 segundos
                if (currentLevel <= 6) return 2000;      // NÃ­veis 5-6: 2 segundos
                if (currentLevel <= 8) return 1500;      // NÃ­veis 7-8: 1.5 segundos
                return 1000;                             // NÃ­veis 9+: 1 segundo
            };
            
            const previewTime = getPreviewTime(level);
            
            // Bloqueia a interaÃ§Ã£o durante a prÃ©via
            isBoardLocked = true;
            
            // Mostra todos os emojis e cores
            cards.forEach(card => {
                card.style.background = card.dataset.color;
                card.style.color = 'white';
                card.classList.add('flipped');
            });
            
            // Adiciona efeito visual de "memorize" com tempo dinÃ¢mico
            const previewOverlay = document.createElement('div');
            previewOverlay.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.8);
                color: #f8fafc;
                padding: 12px 24px;
                border-radius: 12px;
                font-size: 1.2rem;
                font-weight: 600;
                z-index: 1000;
                border: 2px solid rgba(99, 102, 241, 0.5);
                box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
                backdrop-filter: blur(8px);
            `;
            previewOverlay.textContent = `Memorize as posiÃ§Ãµes... (${previewTime/1000}s)`;
            gameContainer.appendChild(previewOverlay);
            
            // Esconde novamente apÃ³s o tempo calculado
            setTimeout(() => {
                cards.forEach(card => {
                    card.style.background = '#0b1020';
                    card.style.color = 'transparent';
                    card.classList.remove('flipped');
                });
                
                // Remove o overlay de memorizaÃ§Ã£o
                if (previewOverlay.parentNode) {
                    previewOverlay.parentNode.removeChild(previewOverlay);
                }
                
                // Desbloqueia a interaÃ§Ã£o
                isBoardLocked = false;
            }, previewTime);
        }

        function resizeGrid() {
            // Apenas recalcula o tamanho do grid sem regenerar o conteÃºdo
            const isMobile = window.innerWidth <= 540;
            const isTablet = window.innerWidth <= 768 && window.innerWidth > 540;
            
            if (isMobile) {
                // Mobile: ocupa 100% da largura com margem de seguranÃ§a
                const containerWidth = window.innerWidth - 16; // 8px margin de cada lado
                const padding = 16; // 8px * 2
                const gap = 4;
                const cell = Math.floor((containerWidth - padding - (gridSize - 1) * gap) / gridSize);
                gameContainer.style.gridTemplateColumns = `repeat(${gridSize}, ${cell}px)`;
                gameContainer.style.gridTemplateRows = `repeat(${gridSize}, ${cell}px)`;
                gameContainer.style.width = `${containerWidth}px`;
                gameContainer.style.height = 'auto';
            } else if (isTablet) {
                // Tablet: tamanho mÃ©dio
                const maxWidth = window.innerWidth - 60;
                const maxHeight = window.innerHeight - 180;
                const availableSize = Math.min(maxWidth, maxHeight);
                const padding = 30;
                const gap = 8;
                const cell = Math.floor((availableSize - padding - (gridSize - 1) * gap) / gridSize);
                gameContainer.style.gridTemplateColumns = `repeat(${gridSize}, ${cell}px)`;
                gameContainer.style.gridTemplateRows = `repeat(${gridSize}, ${cell}px)`;
                gameContainer.style.width = `${availableSize}px`;
                gameContainer.style.height = `${availableSize}px`;
            } else {
                // PC: ocupa toda a tela disponÃ­vel
                const maxWidth = window.innerWidth - 40; // 20px margin de cada lado
                const maxHeight = window.innerHeight - 200; // EspaÃ§o para header e info bar
                const availableSize = Math.min(maxWidth, maxHeight);
                const padding = 40; // 20px * 2
                const gap = 12;
                const cell = Math.floor((availableSize - padding - (gridSize - 1) * gap) / gridSize);
                gameContainer.style.gridTemplateColumns = `repeat(${gridSize}, ${cell}px)`;
                gameContainer.style.gridTemplateRows = `repeat(${gridSize}, ${cell}px)`;
                gameContainer.style.width = `${availableSize}px`;
                gameContainer.style.height = `${availableSize}px`;
            }
        }

        function generateBoard() {
            gameContainer.innerHTML = '';
            
            gridSize = 2 + (level - 1) * 2; // 2,4,6,8,10
            if (gridSize > 10) gridSize = 10;

            totalPairs = (gridSize * gridSize) / 2;
            

            // Gera emojis Ãºnicos para cada par (todos com a mesma cor)
            const cardData = [];
            
            // Embaralha os emojis Ãºnicos para garantir variedade
            const uniqueEmojis = getUniqueEmojis();
            const availableEmojis = shuffle([...uniqueEmojis]);
            
            // Debug: verifica quantos emojis Ãºnicos temos
            console.log(`Total de emojis Ãºnicos disponÃ­veis: ${uniqueEmojis.length}`);
            console.log(`Pares necessÃ¡rios para este nÃ­vel: ${totalPairs}`);
            
            // Cor Ãºnica para todos os cards
            const uniformColor = '#4F46E5'; // Cor roxa consistente
            
            for (let i = 0; i < totalPairs; i++) {
                // Pega o prÃ³ximo emoji disponÃ­vel e remove da lista
                const emoji = availableEmojis.shift();
                
                cardData.push({ color: uniformColor, emoji });
            }
            
            // Cria a moldura de referÃªncia com os emojis Ãºnicos
            createReferenceFrame(cardData);
            
            // Cria pares Ãºnicos - cada emoji aparece exatamente 2 vezes
            const pairedData = [];
            cardData.forEach(item => {
                pairedData.push({...item}); // Primeira instÃ¢ncia
                pairedData.push({...item}); // Segunda instÃ¢ncia (par)
            });
            
            // Embaralha os pares
            const shuffledData = shuffle(pairedData);

            // Calcula tamanho responsivo
            resizeGrid();

            for (let i = 0; i < shuffledData.length; i++) {
                const card = document.createElement('div');
                card.classList.add('card');
                card.dataset.color = shuffledData[i].color;
                card.dataset.emoji = shuffledData[i].emoji;
                card.style.background = '#0b1020'; // Inicia com cor escura
                card.textContent = shuffledData[i].emoji; // Adiciona o emoji
                card.style.fontSize = 'clamp(2.5rem, 6vw, 4rem)'; // Tamanho maior e responsivo do emoji
                card.style.display = 'flex';
                card.style.alignItems = 'center';
                card.style.justifyContent = 'center';
                card.style.color = 'transparent'; // Emoji invisÃ­vel inicialmente

                card.addEventListener('click', flipCard);
                gameContainer.appendChild(card);
            }
            gameContainer.appendChild(gameOverlay);
        }

        function checkMatch() {
            if (firstCard.dataset.emoji === secondCard.dataset.emoji) {
                // Play correct sound
                if (audioSystem) audioSystem.playSound('correct');
                
                // Sistema de PowerUps - acerto
                consecutiveHits++;
                consecutiveMisses = 0;
                lastActionWasHit = true;
                updateConsecutiveMisses();
                
                // Adiciona pontos de PowerUp baseado em acertos consecutivos
                addPowerUpPoints(consecutiveHits);
                
                // Marca o emoji como encontrado na moldura de referÃªncia
                markEmojiAsFound(firstCard.dataset.emoji);
                
                disableCards();
                pairsFound++;
                pairsFoundElement.textContent = pairsFound;
                if (pairsFound === totalPairs) {
                    if (gridSize >= 10) {
                        endGame();
                    } else {
                        levelComplete();
                    }
                }
            } else {
                // Play incorrect sound
                if (audioSystem) audioSystem.playSound('incorrect');
                
                // Sistema de puniÃ§Ãµes - erro
                consecutiveMisses++;
                consecutiveHits = 0;
                lastActionWasHit = false;
                updateConsecutiveMisses();
                
                // Aplica puniÃ§Ãµes baseadas em erros consecutivos
                if (consecutiveMisses === 3) {
                    console.log('PuniÃ§Ã£o: 3 erros consecutivos - embaralhando cards!');
                    shuffleRemainingCards();
                } else if (consecutiveMisses === 5) {
                    console.log('PuniÃ§Ã£o: 5 erros consecutivos - embaralhando e revertendo acerto!');
                    // Primeiro reverte o acerto, depois embaralha
                    revertLastHit();
                    setTimeout(() => {
                        shuffleRemainingCards();
                    }, 100);
                }
                
                unflipCards();
            }
        }

        function disableCards() {
            firstCard.removeEventListener('click', flipCard);
            secondCard.removeEventListener('click', flipCard);
            
            // Marca os cards como encontrados
            firstCard.classList.add('found');
            secondCard.classList.add('found');
            
            resetBoard();
        }

        function unflipCards() {
            isBoardLocked = true;
            setTimeout(() => {
                // Esconde as cores e emojis novamente
                firstCard.style.background = '#0b1020';
                secondCard.style.background = '#0b1020';
                firstCard.style.color = 'transparent'; // Esconde o emoji
                secondCard.style.color = 'transparent'; // Esconde o emoji
                firstCard.classList.remove('flipped');
                secondCard.classList.remove('flipped');
                resetBoard();
            }, 750);
        }

        function resetBoard() {
            [firstCard, secondCard] = [null, null];
            isBoardLocked = false;
        }

        function flipCard() {
            if (isBoardLocked) return;
            if (this === firstCard) return;

            // Play select sound
            if (audioSystem) audioSystem.playSound('select');

            // Mostra a cor e o emoji do card
            this.style.background = this.dataset.color;
            this.style.color = 'white'; // Mostra o emoji
            this.classList.add('flipped');

            if (!firstCard) {
                firstCard = this;
                return;
            }

            secondCard = this;
            checkMatch();
        }
        
        function startGame() {
            pairsFound = 0;
            level = 1;
            levelElement.textContent = level;
            pairsFoundElement.textContent = pairsFound;
            isBoardLocked = false;
            resetBoard();
            
            // Reset PowerUp system
            powerUpPoints = 0;
            consecutiveHits = 0;
            consecutiveMisses = 0;
            lastActionWasHit = false;
            updatePowerUpPoints();
            updateConsecutiveMisses();

            gameOverlay.classList.remove('visible');

            // Esconde o tÃ­tulo quando o jogo comeÃ§a
            const gameTitle = document.getElementById('game-title');
            gameTitle.classList.add('hidden');

            // Start background music
            if (audioSystem) audioSystem.playMusic('game');

            generateBoard();
            addCardListeners();
            
            // Calcula o tempo de prÃ©via baseado no nÃ­vel
            const getPreviewTime = (currentLevel) => {
                if (currentLevel <= 2) return 3000;      // NÃ­veis 1-2: 3 segundos
                if (currentLevel <= 4) return 2500;      // NÃ­veis 3-4: 2.5 segundos
                if (currentLevel <= 6) return 2000;      // NÃ­veis 5-6: 2 segundos
                if (currentLevel <= 8) return 1500;      // NÃ­veis 7-8: 1.5 segundos
                return 1000;                             // NÃ­veis 9+: 1 segundo
            };
            
            const previewTime = getPreviewTime(level);
            
            // Inicia o cronÃ´metro apÃ³s a prÃ©via terminar
            setTimeout(() => {
                levelStartTs = Date.now();
                startTick();
            }, previewTime);
            
            // Inicia a prÃ©via imediatamente
            showAllEmojisPreview();
        }

        function levelComplete() {
            // Play level up sound
            if (audioSystem) audioSystem.playSound('levelUp');
            
            stopTick();
            const elapsedMs = Date.now() - levelStartTs;
            const timeStr = formatTime(elapsedMs);

            registerLevelTime(level, elapsedMs);
            const stars = getStarsForLevel(level, elapsedMs);

            overlayTimeValue.textContent = timeStr;
            overlayTime.classList.remove('hidden');
            overlayStars.classList.remove('hidden');
            overlayStars.textContent = 'â­'.repeat(stars) + 'â˜†'.repeat(5 - stars);

            gameOverlay.classList.add('visible');
            document.getElementById('overlay-title').textContent = `NÃ­vel ${level} concluÃ­do!`;
            document.getElementById('overlay-subtitle').textContent = 'Ã“timo! Vamos para o prÃ³ximo.';
            
            // Mostra o tÃ­tulo novamente
            const gameTitle = document.getElementById('game-title');
            gameTitle.classList.remove('hidden');

            restartButton.textContent = 'PrÃ³ximo nÃ­vel';

            restartButton.onclick = () => {
                gameOverlay.classList.remove('visible');
                pairsFound = 0;
                level++;
                levelElement.textContent = level;
                pairsFoundElement.textContent = pairsFound;
                
                generateBoard();
                addCardListeners();
                
                // Calcula o tempo de prÃ©via baseado no nÃ­vel
                const getPreviewTime = (currentLevel) => {
                    if (currentLevel <= 2) return 3000;      // NÃ­veis 1-2: 3 segundos
                    if (currentLevel <= 4) return 2500;      // NÃ­veis 3-4: 2.5 segundos
                    if (currentLevel <= 6) return 2000;      // NÃ­veis 5-6: 2 segundos
                    if (currentLevel <= 8) return 1500;      // NÃ­veis 7-8: 1.5 segundos
                    return 1000;                             // NÃ­veis 9+: 1 segundo
                };
                
                const previewTime = getPreviewTime(level);
                
                // Inicia o cronÃ´metro apÃ³s a prÃ©via terminar
                setTimeout(() => {
                    levelStartTs = Date.now();
                    startTick();
                }, previewTime);
                
                // Inicia a prÃ©via imediatamente
                showAllEmojisPreview();
            };
        }

        function endGame() {
            // Play game over sound
            if (audioSystem) audioSystem.playSound('gameOver');
            
            stopTick();
            const elapsedMs = Date.now() - levelStartTs;
            const timeStr = formatTime(elapsedMs);
            registerLevelTime(level, elapsedMs);
            const stars = getStarsForLevel(level, elapsedMs);

            overlayTimeValue.textContent = timeStr;
            overlayTime.classList.remove('hidden');
            overlayStars.classList.remove('hidden');
            overlayStars.textContent = 'â­'.repeat(stars) + 'â˜†'.repeat(5 - stars);

            document.getElementById('overlay-title').textContent = 'Jogo concluÃ­do!';
            document.getElementById('overlay-subtitle').textContent = 'ParabÃ©ns por completar todos os nÃ­veis!';
            restartButton.textContent = 'Jogar novamente';
            gameOverlay.classList.add('visible');
            
            // Mostra o tÃ­tulo novamente
            const gameTitle = document.getElementById('game-title');
            gameTitle.classList.remove('hidden');

            restartButton.onclick = () => {
                pairsFound = 0;
                level = 1;
                levelElement.textContent = level;
                pairsFoundElement.textContent = pairsFound;
                gameOverlay.classList.remove('visible');
                
                generateBoard();
                addCardListeners();
                
                // Calcula o tempo de prÃ©via baseado no nÃ­vel
                const getPreviewTime = (currentLevel) => {
                    if (currentLevel <= 2) return 3000;      // NÃ­veis 1-2: 3 segundos
                    if (currentLevel <= 4) return 2500;      // NÃ­veis 3-4: 2.5 segundos
                    if (currentLevel <= 6) return 2000;      // NÃ­veis 5-6: 2 segundos
                    if (currentLevel <= 8) return 1500;      // NÃ­veis 7-8: 1.5 segundos
                    return 1000;                             // NÃ­veis 9+: 1 segundo
                };
                
                const previewTime = getPreviewTime(level);
                
                // Inicia o cronÃ´metro apÃ³s a prÃ©via terminar
                setTimeout(() => {
                    levelStartTs = Date.now();
                    startTick();
                }, previewTime);
                
                // Inicia a prÃ©via imediatamente
                showAllEmojisPreview();
            };
        }

        function addCardListeners() {
            const cards = document.querySelectorAll('.card');
            cards.forEach(card => card.addEventListener('click', flipCard));
            totalPairsElement.textContent = totalPairs;
        }

        window.addEventListener('load', () => {
            // Initialize audio system
            audioSystem = new AudioSystem();
            
            // Setup audio toggle buttons
            musicToggle.addEventListener('click', () => {
                const enabled = audioSystem.toggleMusic();
                musicToggle.classList.toggle('active', enabled);
                musicToggle.textContent = enabled ? 'ğŸµ' : 'ğŸ”‡';
            });
            
            sfxToggle.addEventListener('click', () => {
                const enabled = audioSystem.toggleSFX();
                sfxToggle.classList.toggle('active', enabled);
                sfxToggle.textContent = enabled ? 'ğŸ”Š' : 'ğŸ”‡';
            });
            
            // Setup PowerUp buttons
            reveal1sBtn.addEventListener('click', () => {
                if (spendPowerUpPoints(1)) {
                    revealAllCards(1);
                }
            });
            
            reveal2sBtn.addEventListener('click', () => {
                if (spendPowerUpPoints(4)) {
                    revealAllCards(2);
                }
            });
            
            reveal3sBtn.addEventListener('click', () => {
                if (spendPowerUpPoints(8)) {
                    revealAllCards(3);
                }
            });
            
            solveEmojiBtn.addEventListener('click', () => {
                if (spendPowerUpPoints(4)) {
                    solveSpecificEmoji();
                }
            });
            
            // Set initial button states
            musicToggle.classList.add('active');
            sfxToggle.classList.add('active');
            
            // Initialize PowerUp system
            updatePowerUpPoints();
            updateConsecutiveMisses();
            
            gameOverlay.classList.add('visible');
            restartButton.textContent = 'Iniciar Jogo';
            restartButton.onclick = startGame;
            generateBoard();
            
            // Redimensionar grid quando a janela for redimensionada
            window.addEventListener('resize', () => {
                if (gameContainer.children.length > 0 && !gameOverlay.classList.contains('visible')) {
                    resizeGrid();
                }
            });
        });

        function startTick() {
            stopTick();
            tick = setInterval(() => {
                const elapsed = Date.now() - levelStartTs;
                levelTimeElement.textContent = formatTime(elapsed);
            }, 200);
        }

        function stopTick() {
            if (tick) {
                clearInterval(tick);
                tick = null;
            }
        }

        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, '0');
            const seconds = String(totalSeconds % 60).padStart(2, '0');
            return `${minutes}:${seconds}`;
        }

        function registerLevelTime(currentLevel, elapsedMs) {
            const list = bestTimes.get(currentLevel) || [];
            list.push(elapsedMs);
            list.sort((a, b) => a - b);
            bestTimes.set(currentLevel, list.slice(0, 5));
        }

        function getStarsForLevel(currentLevel, elapsedMs) {
            const list = bestTimes.get(currentLevel) || [elapsedMs];
            const idx = list.indexOf(elapsedMs);
            const position = idx === -1 ? list.length - 1 : idx; // 0 = melhor
            const stars = 5 - position; // melhor=5 ... pior=1
            return Math.max(1, Math.min(5, stars));
        }
        
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey === true || event.metaKey === true) {
                if (event.key === '-' || event.key === '=' || event.key === '0') {
                    event.preventDefault();
                }
            }
        });

        document.addEventListener('wheel', function(event) {
            if (event.ctrlKey === true || event.metaKey === true) {
                event.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>
